<!doctype html>
<html lang="es">
<head>
<title>Apuntes del Curso Análisis Estático de Programas Lógicos</title>
<!-- 2020-10-09 vie 18:18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Christian Gimenez">
<link href="libs/bootstrap.min.css" rel="stylesheet">
<link href="css/style-org.css" rel="stylesheet">
<script src="libs/jquery.min.js"></script>
<script src="libs/bootstrap.min.js"></script>
<meta name="description" content="Apuntes del curso de Análisis Estático Estático de Programas Lógicos. ">
<meta name="keywords" content="Prolog, Ciao, CiaoPP, Análisis Estático">
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Aserciones</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. Formato</a>
<ul class="nav">
<li><a href="#sec-1-1-1">1.1.1. Azúcares sintácticos</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. regtype</a></li>
<li><a href="#sec-1-3">1.3. comp</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Checking</a></li>
<li><a href="#sec-3">3. Teoría</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. Propiedades de la interpretación abstracta</a></li>
<li><a href="#sec-3-2">3.2. Aproximaciones correctas</a></li>
<li><a href="#sec-3-3">3.3. Función de concretización</a></li>
<li><a href="#sec-3-4">3.4. Función de abstracción</a></li>
<li><a href="#sec-3-5">3.5. Significado abstracto</a>
<ul class="nav">
<li><a href="#sec-3-5-1">3.5.1. Significado abstracto segura</a></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6. Semánticas colectoras</a>
<ul class="nav">
<li><a href="#sec-3-6-1">3.6.1. Estructura de Retículo</a></li>
</ul>
</li>
<li><a href="#sec-3-7">3.7. Inserción de Galois</a>
<ul class="nav">
<li><a href="#sec-3-7-1">3.7.1. Aproximación Segura</a></li>
<li><a href="#sec-3-7-2">3.7.2. Teorema fundamental</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Análisis de Programas Lógicos</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. Semántica de Punto Fijo</a>
<ul class="nav">
<li><a href="#sec-4-1-1">4.1.1. Definiciones</a></li>
<li><a href="#sec-4-1-2">4.1.2. Ejemplo</a></li>
<li><a href="#sec-4-1-3">4.1.3. Interpretación abstracta "Bottom Up"</a></li>
<li><a href="#sec-4-1-4">4.1.4. Ejemplo de inferencia de "tipos"</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title">Apuntes del Curso Análisis Estático de Programas Lógicos</h1>
<p>
El siguiente es una apunte del curso <i>Análisis Estático de Programas Lógicos Basado en Interpretación Abstracta</i>.
</p>

<ul class="org-ul">
<li>Presentación: <a href="https://vaucheret.github.io/AILP/ailp.html">HTML</a> | <a href="https://github.com/vaucheret/vaucheret.github.io/tree/932b7f5b158c756c487cac700ba8eb080cf4340d/AILP">Fuentes</a>
</li>
<li>Fuentes de este apunte: <a href="https://github.com/cnngimenez/apuntes-AILP">Repositorio en Github</a>
</li>
<li>Códigos usados:  <a href="https://github.com/cnngimenez/apuntes-AILP/tree/main/tangled">Ver directorio ./tangled/</a>
</li>
<li>Descargar códigos y fuentes completo: <a href="https://github.com/cnngimenez/apuntes-AILP/archive/main.zip">Descargar ZIP completo</a> (O ir al repositorio de Github).
</li>
</ul>


<figure>
<p><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" class="img-responsive" alt="88x31.png">
</p>
</figure>

<p>
This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
</p>

<p>
Este obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional</a>.
</p>


<p>
Los mismos términos utilizados en Ciao Prolog (definiciones de term, atom, predicate, etc.) también se pueden encontrar en el <a href="https://www.swi-prolog.org/pldoc/man?section=glossary">glosario de SWI-Prolog</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Aserciones</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Formato</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Normalmente, el formato de las aserciones en prolog sigue al siguiente estructura:
</p>

<pre class="example">
:- [estado] [aserción] [pred] [: precond] [=&gt; postcond] [+ propcomp] [# "comentario"]
</pre>


<p>
La tabla <a href="tab:aserciones_estados">tab:aserciones_estados</a> describe los distintos valores del campo <code>[estado]</code>. Éstos pueden ser escritos por el usuario o por CiaoPP como salida del chequeo. Los estados que mayormente se escriben por el usuario es <code>trust</code> y <code>check</code>.
</p>

<p>
Los tipos de aserciones que se escriben en el campo <code>[aserción]</code> están detallados en la tabla <a href="tab:aserciones_tipos">tab:aserciones_tipos</a>.
</p>

<p>
Usualmente, una aserción es interpreta de la siguiente manera:
</p>

<ul class="org-ul">
<li><code>[pred]</code> es la llamada al predicado (<i>goal</i>) y debe ser cierta.
</li>
<li><code>[: precond]</code> si existe debe ser verdadera.
</li>
<li>Entonces, <code>[=&gt; postcond]</code> debe complirse, en cuyo caso el preprocesador retornará <code>true</code> o <code>checked</code> en el <code>[estado]</code>.
</li>
<li>La propiedad de computaciónd indicada en <code>[+ propcomp]</code> debe cumplirse.
</li>
</ul>

<p>
Si <code>[pred]</code> o <code>[: precond]</code> no se cumple, no se chequea la postcondición ni al propiedad de computabilidad. La aserción queda en forma de warning con <code>check</code> como estado.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">
<caption class="t-above"><span class="table-number">Tabla 1</span> Estados posibles de la aserción. <a href="tab:aserciones_estados">tab:aserciones_estados</a></caption>

<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">Estado</th>
<th scope="col" class="text-left">Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">trust</td>
<td class="text-left">Ingresada por el usuario,</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">confiar en la veracidad de la aserción.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">checked</td>
<td class="text-left">La aserción fue verificada</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">true</td>
<td class="text-left">Salida del compilador.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">false</td>
<td class="text-left">Error de compilación</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">check</td>
<td class="text-left">Aserción con warnings, chequear aserción.</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>AS: Azúcar Sintáctico
</li>
</ul>

<table class="table table-striped table-bordered table-hover table-condensed">
<caption class="t-above"><span class="table-number">Tabla 2</span> Tipos de aserciones y su significado. <a href="tab:aserciones_tipos">tab:aserciones_tipos</a></caption>

<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">Aserción</th>
<th scope="col" class="text-left">Significado</th>
<th scope="col" class="text-left">AS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">pred</td>
<td class="text-left">Equivalente a calls, success y comp juntos</td>
<td class="text-left">sí</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">(dependiendo de los campos completados).</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">calls</td>
<td class="text-left">La llamada del predicado debe satisfacer</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">la precondición indicada.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">entry</td>
<td class="text-left">Similar a calls pero declara la llamadas</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">exportadas. Son confiadas por el compilador.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">comp</td>
<td class="text-left">Toda llamada del predicado que cumpla con la</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">precondición, debe cumplir con la propiedad</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">de la computación dada.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">regtype</td>
<td class="text-left">Declara un tipo regular.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">success</td>
<td class="text-left">El predicado que cumpla con la precondición</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">&#xa0;</td>
<td class="text-left">y retorne éxito debe verificar la postcondición.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">doc</td>
<td class="text-left">Documentación utilizada por Pldoc</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="text-left">test</td>
<td class="text-left">Testeo con instancias. Similar a success.</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
<code>test</code> no se verifica con CiaoPP porque no trabaja con dominios abstractos.
</p>

<p>
Más información en los manuales de info (en Emacs posicionar el cursor sobre un link y presionar <code>C-c C-o</code>).
</p>

<ul class="org-ul">
<li>Aserciones: <a href="ciao#The Ciao assertion language">info:ciao#The Ciao assertion language</a>.
</li>
<li>Tipos de datos básicos y propiedades: <a href="ciao#Basic data types and properties">info:ciao#Basic data types and properties</a> (predicados como <code>term/1, atm/1, list/1, list/2, num/1</code>, etc.).
</li>
<li>Aserciones de computabilidad: <a href="ciao#Properties which are native to analyzers">ciao#Properties which are native to analyzers</a>.
</li>
<li>Explicación de los tipos regulares: <a href="ciao#Declaring regular types">info:ciao#Declaring regular types</a>.
</li>
<li>Sintaxis para la documentation con PlDoc: <a href="ciao#Documentation comments">info:ciao#Documentation comments</a>.
</li>
</ul>

<p>
Módulos a utilizar:
</p>

<ul class="org-ul">
<li><code>assertions</code>
</li>
<li><code>regtypes</code>
</li>
<li><code>nativeprops</code>
</li>
<li><code>basic_props</code> (este módulo es importado automáticamente con <code>assertions</code>)
</li>
</ul>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Azúcares sintácticos</h4>
<div class="outline-text-4" id="text-1-1-1">
<pre class="example">
pred qsort(A,B) : (list(A), var(B)) =&gt; list(B) + not_fails.
</pre>


<p>
Es equivalente a lo siguiente:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #1e90ff; font-weight: bold;">:- calls</span> qsort(<span style="color: #eedd82;">A</span>,<span style="color: #eedd82;">B</span>) : (list(<span style="color: #eedd82;">A</span>), var(<span style="color: #eedd82;">B</span>)).
<span style="color: #1e90ff; font-weight: bold;">:- success</span> qsort(<span style="color: #eedd82;">A</span>,<span style="color: #eedd82;">B</span>) : (list(<span style="color: #eedd82;">A</span>), var(<span style="color: #eedd82;">B</span>)) <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> list(<span style="color: #eedd82;">B</span>).
<span style="color: #1e90ff; font-weight: bold;">:- comp</span> qsort(<span style="color: #eedd82;">A</span>,<span style="color: #eedd82;">B</span>) : (list(<span style="color: #eedd82;">A</span>) , var(<span style="color: #eedd82;">B</span>)) + not_fails.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> regtype</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Para utilizar <code>regtype</code>, se debe agregar el módulo <code>regtypes</code>. Más información en: <a href="ciao#Declaring regular types">info:ciao#Declaring regular types</a>.
</p>

<p>
Declara como tipos regulares un predicado. En otras palabras, declararía un dominio abstracto. Luego se puede utilizar en otras aserciones para chequear que una varible está en un dominio.
</p>

<p>
Por ejemplo, en el código del autómata se puede utilizar el tipo regtype para declarar el tipo <code>car/1</code> y en el entry se declara que C es una lista con dominio en <code>car/1</code> y S de tipo <code>initial/1</code>
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(aut, <span style="color: #eedd82;">_</span>, [assertions, regtypes]).

<span style="color: #a52a2a; font-weight: bold;">:- entry</span> accepts_(<span style="color: #eedd82;">S</span>,<span style="color: #eedd82;">C</span>) : (initial(<span style="color: #eedd82;">S</span>), list(car, <span style="color: #eedd82;">C</span>)).
<span style="color: #1e90ff; font-weight: bold;">:- regtype</span> car/1.

<span style="color: #87cefa;">car</span>(a).
<span style="color: #87cefa;">car</span>(b).

<span style="color: #6c7b8b;">%% ...</span>
<span style="color: #87cefa;">accepts_</span>(<span style="color: #eedd82;">State</span>, []) <span style="color: #ff7f50; font-weight: bold;">:-</span>
    final(<span style="color: #eedd82;">State</span>).
<span style="color: #6c7b8b;">%% ...</span>
</pre>
</div>

<p>
El analizador de código de CiaoPP puede generar nuevos regtypes para declarar nuevos dominios. Por ejemplo, en el siguiente código se generan dos regtypes, <code>rt4/1</code> y <code>rt5/1</code> definiendo los dominios de las dos variables de <code>te/2</code>. 
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(app, <span style="color: #eedd82;">_</span>, [assertions, nativeprops]).

<span style="color: #87cefa;">te</span>(1, <span style="color: #ffa07a;">"hello"</span>).
<span style="color: #87cefa;">te</span>(0, 0).
</pre>
</div>

<p>
La salida del analizador es la siguiente:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>,[assertions,nativeprops,regtypes]).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> te(<span style="color: #eedd82;">_A</span>,<span style="color: #eedd82;">_B</span>)
   : ( term(<span style="color: #eedd82;">_A</span>), term(<span style="color: #eedd82;">_B</span>) )
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> ( rt4(<span style="color: #eedd82;">_A</span>), rt5(<span style="color: #eedd82;">_B</span>) ).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> te(<span style="color: #eedd82;">_A</span>,<span style="color: #eedd82;">_B</span>)
   : mshare([[<span style="color: #eedd82;">_A</span>],[<span style="color: #eedd82;">_A</span>,<span style="color: #eedd82;">_B</span>],[<span style="color: #eedd82;">_B</span>]])
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> ground([<span style="color: #eedd82;">_A</span>,<span style="color: #eedd82;">_B</span>]).

<span style="color: #87cefa;">te</span>(1,<span style="color: #ffa07a;">"hello"</span>).
<span style="color: #87cefa;">te</span>(0,0).


<span style="color: #1e90ff; font-weight: bold;">:- regtype</span> rt4/1.
<span style="color: #87cefa;">rt4</span>(0).
<span style="color: #87cefa;">rt4</span>(1).

<span style="color: #1e90ff; font-weight: bold;">:- regtype</span> rt5/1.
<span style="color: #87cefa;">rt5</span>(0).
<span style="color: #87cefa;">rt5</span>([104,101,108,108,111]).
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> comp</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Varios de los predicados para <code>comp</code> están definidos en el módulo <code>assertions/native_pros</code>. Es necesario incluirlo en el preámbulo <code>module</code> como <code>nativeprops</code>. Por ejemplo: 
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(the_file, <span style="color: #eedd82;">_</span>, [assertions, nativeprops]).
</pre>
</div>

<p>
O sino, se puede agregar como módulo:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- use_module</span>(library(assertions/native_props)).
</pre>
</div>

<p>
Más información en: <a href="ciao#Properties which are native to analyzers">info:ciao#Properties which are native to analyzers</a>
</p>

<p>
Algunos predicados para chequeo de computación interesantes son: <code>not_fails, no_choicepoints, possibly_fails, fails, non_det, is_det, possibly_nondet, finite_solutions, terminates, exception, no_exception, possible_exceptions</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Checking</h2>
<div class="outline-text-2" id="text-2">
<p>
CiaoPP trabaja sobre dominios abstractos y no concretos. Por ello, <code>test</code> no funcionaría si se brindan datos concretos. En ese caso utilizar los testeos de unidad.
</p>

<p>
Los dominios abstractos se irán creando a medida que sea necesario con nombres de la forma <code>rtNNN</code> donde NNN es un número. A menos que se declaren con <code>regtype/1</code>.
</p>

<p>
Se puede utilizar el predicado <code>output/0</code> en la consola CiaoPP para obtener el archivo con los resultados del análisis y el chequeo. 
</p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Teoría</h2>
<div class="outline-text-2" id="text-3">

<figure>
<p><img src="imgs/summary.png" class="img-responsive" alt="summary.png">
</p>
</figure>

<p>
Siendo:
</p>

<ul class="org-ul">
<li><img src="ltxpng/index_35dc26ab0b4d9c0abc05693f77907ecb1a6d91b2.png" class="img-responsive" alt="$D$"> un dominio concreto.
</li>
<li>D<sub>&alpha;</sub> la abstracción de dicho dominio.
</li>
<li>&alpha; la <b>función de abstracción</b>.
</li>
<li>&gamma; la <b>función de concretización</b>.
</li>
<li><img src="ltxpng/index_8b146da939fdb44255332fdb949e08aaf735a50f.png" class="img-responsive" alt="$\wp (D)$"> es el conjunto partes de <img src="ltxpng/index_35dc26ab0b4d9c0abc05693f77907ecb1a6d91b2.png" class="img-responsive" alt="$D$">. 
</li>
<li><img src="ltxpng/index_29124ddeb9abc53925a26a49c761bf58ea95ccac.png" class="img-responsive" alt="$F_{P} : D \to D$"> es la función concreta que representa al programa <img src="ltxpng/index_a2b343fe2a09ba18dca7d2a770594ba330ad2b96.png" class="img-responsive" alt="$P$">
</li>
<li><img src="ltxpng/index_292b96f69661728c6086e31e0a007cb167e972b3.png" class="img-responsive" alt="$F_\alpha D_\alpha \to D_\alpha$"> la función de significado abstracto de una función F<sub>P</sub>. 
</li>
<li><img src="ltxpng/index_67b2377e4632587c924cfb18d2bc37582dfb5b18.png" class="img-responsive" alt="$F_{P}^{*} : \wp(D) \to \wp(D) \quad F_P^*(S) = \{F_P(x) | x \in S\}$"> es una función dependiente de F<sub>P</sub> que asigna conjuntos de entradas del programa a conjuntos de salida. 
</li>
<li><img src="ltxpng/index_60b6dce95e1aefad4483a618b0ddee1042f33c12.png" class="img-responsive" alt="$\lambda \in D_\alpha$"> un elemento del dominio abstracto.
</li>
<li><img src="ltxpng/index_f5e4c0742284571f24fba8d2b9264943a64bbda5.png" class="img-responsive" alt="$d \in D$"> un elemento del dominio.
</li>
<li><img src="ltxpng/index_944bd4e7cbdd4bfcac01b41f58725cd54b0c25f4.png" class="img-responsive" alt="$\lamda_r$"> resultado/s de la función F<sub>&alpha;</sub>
</li>
<li><img src="ltxpng/index_147c95a9465027cf6eb142dbc2b4f39b3b86b089.png" class="img-responsive" alt="$d_r$"> resultado/s de la función F<sup>*</sup><sub>P</sub>.
</li>
</ul>


<blockquote>

<figure>
<p><img src="imgs/absmean.png" class="img-responsive" alt="absmean.png">
</p>
</figure>

<p>
Considere a &lambda;, <img src="ltxpng/index_526f7674b6fd83bb8d0c6e89f0e9dff9e46b1695.png" class="img-responsive" alt="$d$">, &lambda;<sub>r</sub> y <img src="ltxpng/index_4e9516b71ebcc533dd3918483d513ab6ba214200.png" class="img-responsive" alt="$r$"> como representaciones o etiquetas y no el conjunto o dato en sí. Léase la línea <img src="ltxpng/index_e3041ca67acbee13b023e17675ec5cffe25f0420.png" class="img-responsive" alt="$d \to \lambda$"> usando &alpha; de la siguiente manera: "para representar los valores que existen en lo concreto (d) a lo abstracto (&lambda;) se utiliza la función de abstracción (&alpha;)".
</p>

<p>
En la zona superior se representa un gráfico similar al de la figura que apunta "Dominio abstracto" en el mapa mental. Se resume en que dado un programa y su datos concretos (<img src="ltxpng/index_526f7674b6fd83bb8d0c6e89f0e9dff9e46b1695.png" class="img-responsive" alt="$d$">) se puede obtener su abstracción con &alpha;. Y se puede volver a obtener estos datos concretos utilizando la función &gamma;.
</p>

<p>
En la zona inferior se representa los resultados de aplicar la función que representa al programa sea en abstracto o concreto. 
</p>

<p>
Del lado derecho, se muestra el programa concreto y al aplicarse la función F<sup>*</sup><sub>P</sub> sobre un conjunto de entradas se obtiene las salidas <img src="ltxpng/index_4e9516b71ebcc533dd3918483d513ab6ba214200.png" class="img-responsive" alt="$r$">. 
</p>

<p>
Del lado izquierdo, se presenta la abstracción &lambda; de las entradas, que al aplicarse la función de abstracción F<sub>&alpha;</sub> resulta en &lambda;_r. Este resultado, al concretizarse con &gamma; se obtiene un superconjunto de los resultados dados en <img src="ltxpng/index_4e9516b71ebcc533dd3918483d513ab6ba214200.png" class="img-responsive" alt="$r$">.
</p>
</blockquote>
</div>


<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Propiedades de la interpretación abstracta</h3>
<div class="outline-text-3" id="text-3-1">

<figure>
<p><img src="imgs/1.props_interp_abstr.png" class="img-responsive" alt="1.props_interp_abstr.png">
</p>
</figure>

<p>
Propiedades:
</p>

<ul class="org-ul">
<li>Exactitud: La aproximación realizada (el análisis realizado) ¿es lo más exacto posible? ¿se equivoca dentro de lo esperado? ¿no brinda resultados inconsistentes?
</li>
<li>Terminación: ¿La compilación termina con un resultado?
</li>
<li>Eficiencia: El tiempo de análisis, ¿es el menor? ¿es finito?
</li>
<li>Precision: La información obtenida ¿es precisa?¿brinda un buen detalle de información del/de los programa/s?
</li>
<li>Utilidad: La abstracción, ¿tiene alguna utilidad?. La información que ofrece, ¿vale la pena?
</li>
</ul>


<blockquote>
<ul class="org-ul">
<li>Precisión: Ejemplo: el análisis puede indicarnos que el resultado de un programa es un tipo de dato numérico. Pero sería más preciso si nos indica que es un número positivo. Más aún si indica que es un número positivo y par.
</li>
</ul>
</blockquote>
</div>
</div>


<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Aproximaciones correctas</h3>
<div class="outline-text-3" id="text-3-2">

<figure>
<p><img src="imgs/2.aprox_correctas.png" class="img-responsive" alt="2.aprox_correctas.png">
</p>
</figure>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Función de concretización</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Sea D<sub>&alpha;</sub> un dominio abstracto y <img src="ltxpng/index_abfd4dd8989b9c14d9af4eced9a00f9b515bc8ad.png" class="img-responsive" alt="$\wp(D)$"> partes de (o "conjunto potencia de") un dominio concreto, se dice que <img src="ltxpng/index_846bfd66a1a702ebead9803258c35aea455c8a9f.png" class="img-responsive" alt="$\gamma : D_\alpha \to \wp(D)$"> es la función de concretización.
</p>

<p>
Por ejemplo, sea el dominio abstracto <img src="ltxpng/index_76f9165113c65418ee5152957e5722ff68884428.png" class="img-responsive" alt="$D_\alpha = \{ [-],[0],[+], \top \}$">. Se puede definir a &gamma; de la siguiente manera:
</p>


<figure>
<p><img src="ltxpng/index_2f1cb3e8b82e8d5b9d3611aef805df77d8b1aebf.png" class="img-responsive" alt="\begin{align*}
\gamma([-]) &amp;amp;= \{x \in Z \arrowvert x &amp;lt; 0  \} \\
\gamma([0]) &amp;amp;= \{0\} \\
\gamma([+]) &amp;amp;= \{x \in Z \arrowvert x &amp;gt; 0\} \\
\gamma(\top) &amp;amp;= Z 
\end{align*}
"></p>
</figure>

<p>
Es preciso dar la definición de <img src="ltxpng/index_09bf007a3f2a3f2c52f8d1703040d758ce2216a2.png" class="img-responsive" alt="$\bot$"> : <img src="ltxpng/index_6f9b567a9f6a10730539b95bdb58b30f118cf69d.png" class="img-responsive" alt="$\gamma(\bot) = \emptyset$">.
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Función de abstracción</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Sea D un dominio y D<sub>&alpha;</sub> el dominio abstracto, se define a 
<img src="ltxpng/index_1c295d46e81f69e8f5fcee0a8c0dac57d0537dc3.png" class="img-responsive" alt="$\alpha : \wp(D) \rightarrow D_\alpha$"> como la función de abstracción.
</p>

<p>
Ejemplo: <img src="ltxpng/index_220cb035a6c2ef3b216e9c1f729f66036922290e.png" class="img-responsive" alt="$\alpha({1,2,3}) = [+]$">
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Significado abstracto</h3>
<div class="outline-text-3" id="text-3-5">
<p>
La función <img src="ltxpng/index_29f1b0094cf4ca94080ba9a4c3fe3e38783697b0.png" class="img-responsive" alt="$F_\alpha : D_\alpha \to D_\alpha$"> se denomina <b>función de significado abstracto</b>.
</p>
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Significado abstracto segura</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
Se dice que <img src="ltxpng/index_1fa506a35e1915deaf8f0d2ee7aa0555199e9e61.png" class="img-responsive" alt="$F_\alpha$"> es <b>segura</b> si:
</p>

<p>
<img src="ltxpng/index_cff581cedcf38eb4b2b1ba71f01e196bc074b558.png" class="img-responsive" alt="$$\forall \lambda, \lambda \in D_\alpha, \gamma(F_\alpha(\lambda)) \supseteq F^*_P(\gamma(\lambda))$$">
</p>

<p>
Por ejemplo: Sea <img src="ltxpng/index_96924b22da3441d5a98ac499a53d8d1f478d1ea5.png" class="img-responsive" alt="$P = (y := x * -3)$"> un programa con entrada <img src="ltxpng/index_3773bfa0a05421f0f67e6c4791a370dbe60310e2.png" class="img-responsive" alt="$x$"> y salida <img src="ltxpng/index_f4b063b0f80936b36f97c50c99cf1c25baca9522.png" class="img-responsive" alt="$y$">. 
Entonces la función que representa a este programa concreto es <img src="ltxpng/index_f6c0cff775cb5cb856c1a80f25b834915a2e5713.png" class="img-responsive" alt="$F_P = x * -3$">.
Abstrayéndolo con la función de significado abstracto se obtiene <img src="ltxpng/index_27ee60b17c8aecc590995774928cc1717a78ddd1.png" class="img-responsive" alt="$F_\alpha = x *_\alpha [-]$"> donde <img src="ltxpng/index_5c918963d5dcf3508c4481fcda5a2a7ad980a32a.png" class="img-responsive" alt="$*_\alpha$"> es la operación abstracta de los signos definida en los ejemplos anteriores.
</p>

<p>
Si el programa tiene como entrada un número positivo (<img src="ltxpng/index_64a871fbc878802d59d91f9d55296dcaee414135.png" class="img-responsive" alt="$F_P(x) : x &amp;gt; 0$"> abstrayéndolo resulta en <img src="ltxpng/index_15bd4022ae3a90e36f74c35234553299a0ce5d42.png" class="img-responsive" alt="$F_\alpha([+])$">), entonces se obtiene: <img src="ltxpng/index_f8e10f9591424dcf766b9e6699508f018a29ac9e.png" class="img-responsive" alt="$F_\alpha([+]) = [+] *_\alpha [-] = [-]$">.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Semánticas colectoras</h3>
<div class="outline-text-3" id="text-3-6">
<p>
La semántica I/O que se viene tratando es muy escueta. El análisis de semánticas extendidas se basa en deducir información sobre el estado en los puntos de programa (<i>fixedpoints</i>). Pero diferentes puntos de programa pueden alcanzarse bajo diferentes estados y desde diferentes puntos. Por ello, se necesita calcular una colección semántica de estados abstractos para un punto de programa.
</p>

<p>
Se puede aumentar la eficiencia si se "resume" la semántica recolectada (<i>collecting semantics</i>). Para ello se puede utilizar la estructura de retículo (<i>lattice</i>) en el dominio abstracto.
</p>
</div>


<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1"><span class="section-number-4">3.6.1</span> Estructura de Retículo</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
Se puede estrablecer una operación de orden &le;<sub>&alpha;</sub> sobre el dominio abstracto D<sub>&alpha;</sub>. Si <img src="ltxpng/index_5a17fa7780fda2977e8569a5b9eb30ece7de5b9a.png" class="img-responsive" alt="$(D_\alpha, \le_\alpha)$"> es un retículo completo, entonces para todo <img src="ltxpng/index_d8fa9b8599f35e9d45d7583bb5a288c9a276107e.png" class="img-responsive" alt="$S \subseteq D_\alpha$">, existe un único mínimo límite superior <img src="ltxpng/index_82a48443b88a89a7efcf72ed2277b096aa54c324.png" class="img-responsive" alt="$\sqcup S \in D_\alpha$">. 
</p>

<div class="center">
<p>
El retículo se usa para "resumir" la semántica recolectada de los resultados que se van obteniendo en cada <i>fixpoint</i>.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Inserción de Galois</h3>
<div class="outline-text-3" id="text-3-7">
<p>
Sea:
</p>
<ul class="org-ul">
<li>D y D<sub>&alpha;</sub> retículos completos
</li>
<li><img src="ltxpng/index_3bdf3a5b94afe9a65ada1c7685b5399b453df119.png" class="img-responsive" alt="$\gamma : D_\alpha \to D$"> una función monótona de concretización.
</li>
<li><img src="ltxpng/index_4a0855c9f03664d4647d3ece1ec8be47af1c4b58.png" class="img-responsive" alt="$\alpha : D \to D_\alpha$"> una función monótona de abstracción.
</li>
</ul>

<p>
La estructura <img src="ltxpng/index_c5739c013db1dd677910c8e2a89bc4be019a88cb.png" class="img-responsive" alt="$(D_\alpha, \gamma, D, \alpha)$"> se denomina <b>inserción de Galois</b> si cumple con lo siguiente:
</p>

<ul class="org-ul">
<li><img src="ltxpng/index_a8671c9f19770bfbbc1ca84ac7e03af898f4988e.png" class="img-responsive" alt="$\forall \lambda \in D_\alpha . \lambda = \alpha(\gamma(\lambda))$">
</li>
<li><img src="ltxpng/index_d860a9e96af43001d562f44470ca6080d173f46e.png" class="img-responsive" alt="$\forall d \in D . d \subseteq \gamma(\alpha(d))$">
</li>
</ul>

<blockquote>
<p>
La primer propiedad significa que si se aplica la concretización sobre un resultado abstracto (ej. números positivos <img src="ltxpng/index_754b011c3f0299e4204ccd6d4bb7c46630f83f96.png" class="img-responsive" alt="$[+]$">), y luego la volvemos a abstraer debe dar el mismo resultado y se mantiene consistente.
</p>

<p>
La segunda propiedad significa que si se intenta aplicar la abstracción sobre un resultado particular y luego la concretización, el resultado del cual partimos debe estra en el resultado final de &gamma;.
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1"><span class="section-number-4">3.7.1</span> Aproximación Segura</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
Sea una inserción de Galois <img src="ltxpng/index_c5739c013db1dd677910c8e2a89bc4be019a88cb.png" class="img-responsive" alt="$(D_\alpha, \gamma, D, \alpha)$">. Se dice que <img src="ltxpng/index_60b6dce95e1aefad4483a618b0ddee1042f33c12.png" class="img-responsive" alt="$\lambda \in D_\alpha$"> se aproxima de forma segura a <img src="ltxpng/index_f5e4c0742284571f24fba8d2b9264943a64bbda5.png" class="img-responsive" alt="$d \in D$"> sssi <img src="ltxpng/index_d209a711e4e593cd93aa0639962addd6c8f99ee4.png" class="img-responsive" alt="$d \subseteq \gamma(\lambda)$">.
</p>

<blockquote>
<p>
Una aproximación es segura si al aplicar la función de concretización sobre un elemento abstracto si d.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3-7-2" class="outline-4">
<h4 id="sec-3-7-2"><span class="section-number-4">3.7.2</span> Teorema fundamental</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
Dada una inserción de Galois <img src="ltxpng/index_c5739c013db1dd677910c8e2a89bc4be019a88cb.png" class="img-responsive" alt="$(D_\alpha, \gamma, D, \alpha)$"> y dos funciones monótonas <img src="ltxpng/index_99c36773d8b2a34a20ddc9779d55dbbc8038fd37.png" class="img-responsive" alt="$F : D \to D$"> y <img src="ltxpng/index_29f1b0094cf4ca94080ba9a4c3fe3e38783697b0.png" class="img-responsive" alt="$F_\alpha : D_\alpha \to D_\alpha$">.
</p>

<p>
Si F<sub>&alpha;</sub> es una aproximación de F entonces lfp(F<sub>&alpha;</sub>)<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> es una aproximación de lfp(F).
</p>

<blockquote>
<p>
El teorema fundamental justifica que la aplicación del <img src="ltxpng/index_d645a151490b928d2895db274e0f51aad8a27b7d.png" class="img-responsive" alt="$lfp(F_\alpha)$"> se refleja dentro de la aplicación de <img src="ltxpng/index_d630bea11401e8c03cc64bc7e6d8ec599f66f18b.png" class="img-responsive" alt="$lfp(F)$">.  
</p>

<p>
En otras palabras aplicar <img src="ltxpng/index_d645a151490b928d2895db274e0f51aad8a27b7d.png" class="img-responsive" alt="$lfp(F_\alpha)$"> refleja/mapea/aproxima a <img src="ltxpng/index_2a43c354728865505e8a2bc006d3561f278e9499.png" class="img-responsive" alt="$lfp$"> aplicado a la función que representa nuestro programa concreto, ofreciendo seguridad de que la abstracción aún representa nuestro programa.
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Análisis de Programas Lógicos</h2>
<div class="outline-text-2" id="text-4">

<figure>
<p><img src="imgs/analisis_programas_logicos.png" class="img-responsive" alt="analisis_programas_logicos.png">
</p>
</figure>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Semántica de Punto Fijo</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Definiciones</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>Un lenguaje de primer orden <img src="ltxpng/index_a6405fcb599d4a4f44ee7b27d79d87bcf1805351.png" class="img-responsive" alt="$L$">, asociado a un programa <img src="ltxpng/index_a2b343fe2a09ba18dca7d2a770594ba330ad2b96.png" class="img-responsive" alt="$P$">.
</li>
<li>Sea <img src="ltxpng/index_5951449f7407819fe1197e72bfe8b3f5b414d19d.png" class="img-responsive" alt="$U$"> el <b>Universo de Herbrand</b>: El conjunto de todos los términos básicos de <img src="ltxpng/index_a6405fcb599d4a4f44ee7b27d79d87bcf1805351.png" class="img-responsive" alt="$L$">
</li>
<li>Sea <img src="ltxpng/index_85b9c5bc6feaef7456f192c2199795eb3bd06187.png" class="img-responsive" alt="$B$"> la sa <b>Base de Herbrand</b>: El conjunto de todos los átomos instanciados (<i>ground</i>) de <img src="ltxpng/index_a6405fcb599d4a4f44ee7b27d79d87bcf1805351.png" class="img-responsive" alt="$L$">.
</li>
<li>Una <b>Interpretación de Herbrand</b> es un subconjunto de <img src="ltxpng/index_85b9c5bc6feaef7456f192c2199795eb3bd06187.png" class="img-responsive" alt="$B$">.
</li>
<li>Sea <img src="ltxpng/index_2c22f477e59e4c40702072a716a680f53b0e0a50.png" class="img-responsive" alt="$I$"> es el <b>conjunto de todas las interpretaciones</b> de Herbrand.
</li>
<li>Un <b>Modelo de Herbrand</b> es una interpretación de Herbrand que contiene todas las consecuencias del programa.
</li>
<li>Sea <img src="ltxpng/index_ca7b3fdaf7b753fd858532cf1db59b16109fb961.png" class="img-responsive" alt="$T_P : I \to I$"> el <b>operador de consecuencia inmediata</b>. Está definido por:
</li>
</ul>

<figure>
<p><img src="ltxpng/index_44935b42b4a22b408ae078917e4677891ad46708.png" class="img-responsive" alt="\begin{align*}
T_P(M) =&amp;amp; \{h \in B \vert \exists C \in ground(P) \\
        &amp;amp; C = h \leftarrow b_1, \ldots, b_n \mbox{ y } \\
        &amp;amp; b_1, \ldots, b_n \in M\}
\end{align*}
"></p>
</figure>
<ul class="org-ul">
<li><img src="ltxpng/index_a3d92f5d1e0cb774faf407eb01d9f3d5c4a24490.png" class="img-responsive" alt="$T_P \uparrow \omega$"> es el procedimiento para obtener el mínimo punto fijo comenzando desde <img src="ltxpng/index_5bdbc4759901be3e0f3ffa3f6b66c3c1a3dbe7bb.png" class="img-responsive" alt="$\omega = 1$">.
</li>
</ul>

<p>
Observar que la definición de T<sub>P</sub> depende del programa P.
</p>

<p>
Considerar <img src="ltxpng/index_b95b2ce38fa55a7489b17af1bfe83b15c9c966dd.png" class="img-responsive" alt="$ground(P)$"> como el conjunto de todos los términos instanciados de P.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Ejemplo</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Sea el siguiente programa P:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #87cefa;">p</span>(f(<span style="color: #eedd82;">X</span>)) <span style="color: #ff7f50; font-weight: bold;">:-</span> p(<span style="color: #eedd82;">X</span>).
<span style="color: #87cefa;">p</span>(a).
<span style="color: #87cefa;">q</span>(a).
<span style="color: #87cefa;">q</span>(b).
</pre>
</div>

<p>
Escrito formalmente:
</p>

<p>
<img src="ltxpng/index_0698589b558c27e55982fa302f6aa6ae1baa974f.png" class="img-responsive" alt="$P = \{ p(f(X)) \leftarrow p(X). p(a). q(a). q(b). \}$">
</p>

<p>
El Universo de Herbrand es:
</p>

<p>
<img src="ltxpng/index_e4fa63b7e7a36a83e88acec2f5056a5fc6b080f8.png" class="img-responsive" alt="$$U = \{ a,b,f(a),f(b),f(f(a)),f(f(b)),\ldots \}$$">
</p>

<p>
La Base de Herbrand es:
</p>

<p>
<img src="ltxpng/index_4f3072ec9ee965d62b04f48fe0d9cd97dedc26e1.png" class="img-responsive" alt="$$B = \{ p(a),p(b),q(a),q(b),p(f(a)),p(f(b)),p(f(f(a))), p(f(f(b))), q(f(a))\ldots \}$$">
</p>

<p>
El conjunto de todas las interpretaciones de Herbrand es:
</p>

<p>
<img src="ltxpng/index_afac7ae4a00823b752db058a7a02be9ec08cf201.png" class="img-responsive" alt="$$I = \mbox{ todos los subconjuntos de } B$$">
</p>

<p>
Un modelo de Herbrand es:
</p>

<p>
<img src="ltxpng/index_ebae9d6b8382ae3ac261774af6f210aa4d1f4558.png" class="img-responsive" alt="$$H = \{ q(a), q(b), p(a), p(f(a)), p(f(f(a))), \ldots \}$$">
</p>

<p>
El procedimiento para obtener el mínimo punto fijo es:
</p>


<figure>
<p><img src="ltxpng/index_e773ef3092930e31f14fc444b966941458cd7361.png" class="img-responsive" alt="\begin{align*}
T_P \uparrow 0 &amp;amp;= \{ p(a),q(a),q(b) \}\\
T_P \uparrow 1 &amp;amp;= \{ p(a),q(a),q(b),p(f(a)) \} \\
T_P \uparrow 2 &amp;amp;= \{ p(a),q(a),q(b),p(f(a)),p(f(f(a))) \} \\
\ldots \\
T_P \uparrow \omega &amp;amp;= H
\end{align*}      
"></p>
</figure>

<p>
Como consecuencia T<sub>P</sub> &uarr; &omega; obtiene todas las consecuencias lógicas del programa.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> Interpretación abstracta "Bottom Up"</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Aplicar la interpretación abstracta consiste en definir lo siguiente:
</p>

<ul class="org-ul">
<li>Un dominio abstracto: I<sup>&alpha;</sup>
<ul class="org-ul">
<li>donde sus elementos son aproximaciones de elementos de <img src="ltxpng/index_45ea39fa76529eff21441fb90eac356e5adf6020.png" class="img-responsive" alt="$I = \wp(B)$">
</li>
</ul>
</li>
<li>Función de concretización: &gamma;
<ul class="org-ul">
<li><img src="ltxpng/index_9df86b79631f9860e40e7b870ecb0c1a7fb27f05.png" class="img-responsive" alt="$\gamma : I^\alpha \to I$">
</li>
</ul>
</li>
<li>Función de abstracción: &alpha;
<ul class="org-ul">
<li><img src="ltxpng/index_cd03449e612a091a6e26dee6f03ff4676a86814b.png" class="img-responsive" alt="$\alpha : I \to I^\alpha$">
</li>
</ul>
</li>
<li>Operador abstracto: T<sup>&alpha;</sup><sub>P</sub>
<ul class="org-ul">
<li>Es la versión abstracta de T<sub>P</sub>
</li>
<li><img src="ltxpng/index_7f25cff0f0a21dc16671d0d8b5ee34c2f47428b7.png" class="img-responsive" alt="$T^\alpha_P : I^\alpha \to I^\alpha$">
</li>
</ul>
</li>
<li>Inserción de Galois: <img src="ltxpng/index_6d6f84acb3ec8a6da96a27bbaf1da7d2966e8946.png" class="img-responsive" alt="$(I^\alpha, \gamma, I, \alpha)$">
</li>
</ul>

<p>
Considerar que T<sup>&alpha;</sup><sub>P</sub> depende del programa abstracto P<sub>&alpha;</sub> (sería correcto decir <img src="ltxpng/index_523647eaa87660aa46f0435139b1029627d12155.png" class="img-responsive" alt="$T^{\alpha}_{P_{\alpha}}$"> en vez de T<sup>&alpha;</sup><sub>P</sub>).
</p>

<p>
Para demostrar exactitud o terminación se debe:
</p>
<ul class="org-ul">
<li>Exactitud:
<ul class="org-ul">
<li>I<sup>&alpha;</sup> es un retículo completo
</li>
<li>I<sup>&alpha;</sup> Debe aproximar a <img src="ltxpng/index_50c9e325d86b0026b6c45978e534657f6a105cfc.png" class="img-responsive" alt="$I: \forall M \in I, \gamma(\alpha(M)) \supseteq M$">
</li>
<li>T<sup>&alpha;</sup><sub>P</sub> es una aproximación segura de T<sub>P</sub>
<ul class="org-ul">
<li>i.e. <img src="ltxpng/index_57fed31891d82087d1e6f1c7374fc04a05be7a1a.png" class="img-responsive" alt="$\forall d, d \in  I^\alpha, \gamma(T^\alpha_P(d)) \supseteq T_P(\gamma(d))$">
</li>
</ul>
</li>
</ul>
</li>
<li>Terminacion:
<ul class="org-ul">
<li>T<sup>&alpha;</sup><sub>P</sub> es monótono
</li>
<li>I<sup>&alpha;</sup> cadena ascendente finita.
</li>
</ul>
</li>
</ul>

<p>
Con esto se puede deducir que <img src="ltxpng/index_646662c533b463dfb105b0780ef92e7b589f60ff.png" class="img-responsive" alt="$H^\alpha = lfp(T^\alpha_P) = T^\alpha_P \uparrow n$"> donde:
</p>
<ul class="org-ul">
<li><img src="ltxpng/index_58199a5456c6af107f6ae48293c635a1c794b09c.png" class="img-responsive" alt="$n$"> es el número de pasos (finito)
</li>
<li><img src="ltxpng/index_f64d708628d35e4124669d963106e1933cf531dc.png" class="img-responsive" alt="$H^\alpha$"> aproximará a <img src="ltxpng/index_5b6f0bf7b6c033767d6579998f4d2d430f7d9fb8.png" class="img-responsive" alt="$H$">.
</li>
</ul>

<p>
La Figura <a href="intabs_bottom_up">intabs_bottom_up</a> muestra los elementos indicados anteriormente y la relación entre ellos. Obsérvese la separación entre los dos "dominios" de interpretación e interpretación abstracta y el uso de las funciones de concretización y abstracción para poder "ir y venir" entre ellos.
</p>


<figure>
<p><img src="imgs/bottomup.png" class="img-responsive" alt="bottomup.png">
</p>
<figcaption><span class="figure-number">Figura 7:</span> Relación entre los elementos relevantes de la interpretación abstracta Bottom-Up. <a href="fig:intabs_bottom_up">fig:intabs_bottom_up</a></figcaption>
</figure>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4"><span class="section-number-4">4.1.4</span> Ejemplo de inferencia de "tipos"</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Sea el siguiente programa lógico P:
</p>


<figure>
<p><img src="ltxpng/index_18fd45107c26e5330ebcea06b10bd63777923bce.png" class="img-responsive" alt="\begin{align*}
P = \{ &amp;amp; p(f(X)) \leftarrow p(X).\\
       &amp;amp; p(a).\\
       &amp;amp; r(X) \leftarrow t(X,Y).\\
       &amp;amp; q(a).\\
       &amp;amp; q(b). \}
\end{align*}
"></p>
</figure>

<p>
En prolog:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #87cefa;">p</span>(f(<span style="color: #eedd82;">X</span>)) <span style="color: #ff7f50; font-weight: bold;">:-</span> p(<span style="color: #eedd82;">X</span>). 
<span style="color: #87cefa;">p</span>(a). 
<span style="color: #87cefa;">r</span>(<span style="color: #eedd82;">X</span>) <span style="color: #ff7f50; font-weight: bold;">:-</span> t(<span style="color: #eedd82;">X</span>,<span style="color: #eedd82;">Y</span>). 
<span style="color: #87cefa;">q</span>(a). 
<span style="color: #87cefa;">q</span>(b).
</pre>
</div>

<p>
La representación abstracta de P:
</p>


<figure>
<p><img src="ltxpng/index_779201a17a7eb622bdb5cecf218ccf4f25ce834a.png" class="img-responsive" alt="\begin{align*}
P_\alpha = \{ &amp;amp; p \leftarrow p.\\
         &amp;amp; p.\\ 
         &amp;amp; r \leftarrow t.\\
         &amp;amp; q.\}
\end{align*}
"></p>
</figure>

<p>
Sea <img src="ltxpng/index_6cde8532ceb74172f8d5051008de34ff5429824a.png" class="img-responsive" alt="$B^\alpha = S$"> el conjunto de símbolos de predicado en el programa P, se obtiene:
</p>

<p>
<img src="ltxpng/index_960e64df93edc8b3153734c01f1d61f6d7e8d5f7.png" class="img-responsive" alt="$$S = \{ p/1, q/1, r/1, t/2 \}$$">
</p>

<p>
La función de abstracción <img src="ltxpng/index_4648e0936578526750f4849341835023ca7646b9.png" class="img-responsive" alt="$\alpha : I \to S^*$"> se define como:
</p>

<p>
<img src="ltxpng/index_20f6010e6d239055dc4ae1a8550d97354ff33051.png" class="img-responsive" alt="$$\alpha(\{p(a), p(b), q(a)\}) = \{ p/1, q/1 \}$$">
</p>

<p>
La función de concretización <img src="ltxpng/index_760998268b0a7d8b43c4d25627b00eba2cd352aa.png" class="img-responsive" alt="$\gamma : S^* \to I$"> se define como:
</p>


<figure>
<p><img src="ltxpng/index_323482b4596fb2dfea373dca61425adc1ba78981.png" class="img-responsive" alt="\begin{align*}
\gamma(\{p/1, q/1\}) &amp;amp; = \{ A \in B \;|\; pred(A) = p/1 \; \vee \; pred(A) = q/1\} \\
                &amp;amp; = \{p(a), p(b), p(f(a)), p(f(b)),\ldots, q(a), q(b), q(f(a)),\ldots \} 
\end{align*}
"></p>
</figure>

<p>
Por consiguiente, la versión abstracta de <img src="ltxpng/index_9461f076e656879cc398ad57c6ab2bf5d422d63c.png" class="img-responsive" alt="$T_P$"> es <img src="ltxpng/index_3c08d32d676914b5e72d615559c61a1e8bec7ef9.png" class="img-responsive" alt="$T^\alpha_P : S^* \to S^*$"> se obtiene de la siguiente manera:
</p>


<figure>
<p><img src="ltxpng/index_64991a74fde2c69d213c6c3d823e8e7e1f3dd942.png" class="img-responsive" alt="\begin{align*}
T^\alpha_P \uparrow 0 &amp;amp;= T^\alpha_P(\emptyset) = \{ p/1, q/1 \} \\
T^\alpha_P \uparrow 1 &amp;amp;= T^\alpha_P(\{ p/1, q/1 \}) \\
    &amp;amp;= \{ p/1, q/1 \} \\          
    &amp;amp;= T^\alpha_P \uparrow 0 = H^\alpha
\end{align*}
"></p>
</figure>

<p>
Por consiguiente, los "tipos" de datos deducidos son <img src="ltxpng/index_b084df3e32ae8105af3eadce7f50d4acbe5fa14c.png" class="img-responsive" alt="$\{ p/1, q/1 \} = H^\alpha$">. Obsérvese que H<sup>&alpha;</sup> es la aproximación al modelo de Herbrand <img src="ltxpng/index_5b6f0bf7b6c033767d6579998f4d2d430f7d9fb8.png" class="img-responsive" alt="$H$"> (todas las consecuencias lógicas del programa P).
</p>

<p>
Para utilizar el programa en Ciao Prolog se debe escribir lo siguiente:
</p>
<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(<span style="color: #eedd82;">_</span>, <span style="color: #eedd82;">_</span>, [assertions, nativeprops]).

<span style="color: #87cefa;">p</span>(f(<span style="color: #eedd82;">X</span>)) <span style="color: #ff7f50; font-weight: bold;">:-</span> p(<span style="color: #eedd82;">X</span>). 
<span style="color: #87cefa;">p</span>(a). 
<span style="color: #87cefa;">r</span>(<span style="color: #eedd82;">X</span>) <span style="color: #ff7f50; font-weight: bold;">:-</span> t(<span style="color: #eedd82;">X</span>,<span style="color: #eedd82;">Y</span>). 
<span style="color: #87cefa;">q</span>(a). 
<span style="color: #87cefa;">q</span>(b).

<span style="color: #87cefa;">t</span>(<span style="color: #eedd82;">_</span>,<span style="color: #eedd82;">_</span>).
</pre>
</div>

<p>
El analizador de CiaoPP responde con la siguiente salida:
</p>

<div class="org-src-container">

<pre class="src src-ciao"><span style="color: #9f79ee; font-weight: bold;">:- module</span>(<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>,[assertions,nativeprops,regtypes]).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> p(<span style="color: #eedd82;">_A</span>)
   : term(<span style="color: #eedd82;">_A</span>)
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> rt3(<span style="color: #eedd82;">_A</span>).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> p(<span style="color: #eedd82;">_A</span>)
   : mshare([[<span style="color: #eedd82;">_A</span>]])
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> ground([<span style="color: #eedd82;">_A</span>]).

<span style="color: #87cefa;">p</span>(f(<span style="color: #eedd82;">X</span>)) <span style="color: #ff7f50; font-weight: bold;">:-</span>
    p(<span style="color: #eedd82;">X</span>).
<span style="color: #87cefa;">p</span>(a).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> r(<span style="color: #eedd82;">X</span>)
   : term(<span style="color: #eedd82;">X</span>)
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> term(<span style="color: #eedd82;">X</span>).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> r(<span style="color: #eedd82;">X</span>)
   : mshare([[<span style="color: #eedd82;">X</span>]])
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> mshare([[<span style="color: #eedd82;">X</span>]]).

<span style="color: #87cefa;">r</span>(<span style="color: #eedd82;">X</span>) <span style="color: #ff7f50; font-weight: bold;">:-</span>
    t(<span style="color: #eedd82;">X</span>,<span style="color: #eedd82;">Y</span>).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> q(<span style="color: #eedd82;">_A</span>)
   : term(<span style="color: #eedd82;">_A</span>)
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> rt8(<span style="color: #eedd82;">_A</span>).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> q(<span style="color: #eedd82;">_A</span>)
   : mshare([[<span style="color: #eedd82;">_A</span>]])
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> ground([<span style="color: #eedd82;">_A</span>]).

<span style="color: #87cefa;">q</span>(a).
<span style="color: #87cefa;">q</span>(b).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> t(<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>)
   : ( term(<span style="color: #eedd82;">_1</span>), term(<span style="color: #eedd82;">_2</span>) )
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> ( term(<span style="color: #eedd82;">_1</span>), term(<span style="color: #eedd82;">_2</span>) ).

<span style="color: #1e90ff; font-weight: bold;">:- </span><span style="color: #32cd32; font-weight: bold;">true</span><span style="color: #1e90ff; font-weight: bold;"> pred</span> t(<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>)
   : mshare([[<span style="color: #eedd82;">_1</span>],[<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>],[<span style="color: #eedd82;">_2</span>]])
   <span style="color: #ff7f50; font-weight: bold;">=&gt;</span> mshare([[<span style="color: #eedd82;">_1</span>],[<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>],[<span style="color: #eedd82;">_2</span>]]).

<span style="color: #87cefa;">t</span>(<span style="color: #eedd82;">_1</span>,<span style="color: #eedd82;">_2</span>).


<span style="color: #1e90ff; font-weight: bold;">:- regtype</span> rt3/1.
<span style="color: #87cefa;">rt3</span>(a).
<span style="color: #87cefa;">rt3</span>(f(<span style="color: #eedd82;">A</span>)) <span style="color: #ff7f50; font-weight: bold;">:-</span>
    rt3(<span style="color: #eedd82;">A</span>).

<span style="color: #1e90ff; font-weight: bold;">:- regtype</span> rt8/1.
<span style="color: #87cefa;">rt8</span>(a).
<span style="color: #87cefa;">rt8</span>(b).
</pre>
</div>

<p>
En congruencia con los resultados de <img src="ltxpng/index_f64d708628d35e4124669d963106e1933cf531dc.png" class="img-responsive" alt="$H^\alpha$"> planteados anteriormente, el analizador generó dos declaraciones de <code>regtype</code> denominadas <code>rt3/1</code> y <code>rt8/1</code>. Al observarse los valores, se puede deducir que <code>rt3/1</code> corresponde con los de <code>p/1</code> y <code>rt8/1</code> con los de <code>q/1</code>. 
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Nota al pie de p&aacute;gina: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
lfp significa <i>least fixed point</i>. gfp significa <i>greatest fixed point</i>.
</p></div>


</div>
</div></div></div></div>
<footer id="postamble" class="">
<div><p class="date">Fecha: 02 oct 2020</p>
<p class="author">Autor: Christian Gimenez</p>
<p class="date">Created: 2020-10-09 vie 18:18</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="http://orgmode.org">Org-mode</a> 9.3.6)</p>
</div>
</footer>
</body>
</html>
